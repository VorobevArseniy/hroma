# Определяем название модуля
module main

# Импортируем стандартный модуль
import hroma/io 
# Если импортов несколько:
# import (
#   hroma/io
#   hroma/lists
#   hroma/files
# )
#


# Определяем основную функцию
main : () -> IO string
let main = {
    # Тип для нульярных функций может быть выведен автоматически
    let greeting = "Hello, World!"
        ^-- () -> String
    io.puts greeting # >> Hello, World!

    # ---

    put_expr : String -> IO String
    let put_expr = x -> io.puts x
    put_expr $ "Hello, " <> "World!" # or put_expr ("Hello, " <> "World!")
}

---
# В Hroma все значения - это функции
# Для создания функции используется ключевое слово let:
let foo = 42 # Создает функции foo (), которая возвращает 42

# В Hroma функции могут принимать только один аргумент
: Int -> Int # Nameless bind - сигнатура применится к следующей функции
let bar = x -> x + 42

# Если нужно передать пару аргументов:
: (Int, Int) -> Int
let sum = x, y -> x + y # Скобки писать не нужно
# Тогда вызов функции будет выгядеть так:
sum (40, 2)


# Синтаксис многострочных функций (императивный стиль)
: () -> Int
let multiline_fn = {
    let foo = 24
    let bar = foo * 2

    bar # В Hroma нет ключего слова return, как во многих ЯП
}

# Линейность в Hroma:

let some_fn = {
    let foo = files.open "foo.txt"

    let line1, _  = files.get_line (foo, 1)
    let line2, _ = files.get_line (foo , 2) # foo использован дважды!

    # Правильным будет:
    # let line1, foo2 = files.get_line (foo, 1)
    # let line2, _ = files.get_line (foo2, 2)

    (line1, line2)
} # В языке есть RAII, поэтому файл вручную закрывать не надо

# Многие стандартные примитивные типы имеют NonLin trait
let foo = 42

let bar = foo + foo # Они удаляются из памяти нетривиальным образом

# Нужно быть очень акуратными с NonLin trait и не использовать его для ресурсов, иначе могут случиться утечки памяти
---

---

# Анонимные функции:

\ -> {...} # Анонимная функция с Unit параметром

\x -> {...} # Анонимная функция с параметром

---

---

# Типы данных:
# В Hroma есть ряд встроенных типов: Int, Float, String, Bool, List T, Result (T, E), Record{}, Pair (A, B) и другие

# Records:
# создать запись можно с помощью литерала {}:
let my_record = {foo: 42, bar: "42"} # В таком случае тип записи выведется автоматически 
#   ^-- () -> Record{foo: Int, bar: String}
#
# Получить данные записи можно через . :
let foo = my_record.foo 
#   ^-- () -> Int
#
# Если запись нелинейна, то получать ее данные таким образом можно несколько раз
# Если запись линейна, то получение ее данных таким образом поглотит саму запись, и получить другие данные не получится
# Если надо получить все данные линейной записи, то необходимо воспользоваться pattern matching:
let lin_record = LinRecord {foo: LinType, bar: LinType}

: LinRecord -> ...
let baz = lr ->
    match lr of
        LinRecord {foo, bar} -> {...}

baz lin_record # линейный ресурс поглощен

# Type alias

: (Int, (Int -> Int)) -> Int
let req factorial = n, cont -> 
    match n of
        0 -> cont 1
        _ -> factorial (n - 1, \result -> cont $ n * result)
# Удобнее будет вынести в отдельный alias тип:
let type Cont = Int -> Int

: (Int, Cont) -> Int
let req factorial = n, cont -> {...}

# Result type alias
let type MyResult = Result (Bool, String) # Типы обязательно пишутся с большой буквы!

f : MyResult -> ...
let f = val -> {match val of ...}

# Так же можно задать несоклько вариантов одному типу (ADT)
let type MyType = {
    Foo,
    Baz,
    Bar
}
# Затем это удобно использовать в pattern match
f : MyType -> String
let f = variant ->
    match of variant
        Foo -> "foo!"    
        Bar -> "bar!"
        Baz -> "baz!"
        _ -> "sad"
io.puts $ f Foo # >> foo!

# В конструкторах вариантов можно использовать любые типы
let type MyADT = {
    Foo {data: String, another_data: String} 
    Bar (Int, String)
    Baz List Int
}

: MyRecordType -> IO String
let handle_record = record -> 
    match record of
        Foo {data, another_data} -> io.puts $ "Your data: " <> data <> " " <> another_data
        Bar (baz, _) -> io.puts $ "Baz?: " <> baz # Варианты можно пропускать
        Baz list -> lists.foldl (print, list)


handle_my_record $ Bar ("bar", 42) # >> Baz?: bar
---

---
# Математические операторы:

# Операторы в Hroma не имеют перегрузок:
# Операторы для Int: 
# Арифметические: [+, -, /, *, %]
# Операторы сравнения: [<, >, >=, <=, ==]
#
# Операторы для Float: 
# Арифметические: [+. , -. , /. , *. , %.]
# Операторы сравнения: [<. , >. , >=. , <=.]
#
# Операторы для String
# Оператор конкатинации: <>

# Оператор сравнения работает с любыми типами:
io.puts $ 42 == 42 # >>true
io.puts $ "42" == "42" # >>true
io.puts $ 42 == "42"  # Ошибка компилятора!
# Выдает ошибку при несоответствии типов!
---

---

# Коллекции (списки):
let list = [0, 1, 2] # Это функция, которая создаст список.
# Такой список будет иметь тип List Int
# List не реализует NonLin trait

# Hroma имеет встроенные функции для работы со списками в модуле hroma/lists:
let list = [42, 42, 42]

let len, list = lists.len list1 # Так как в Hroma списки линейны, после использования в функции len
# list будет недоступен. Поэтому len (как и многие другие функции) возвращает заново новую функцию с исходным списком
# Если вам не нужна функция со списком обратно вы можете сделать let len, _ = len list
---

---
# Pattern matching

# Пример pattern matching:
: Int -> Result (String, String)
let matcher = a -> # Result (String, String)
    match a of
        0 -> Ok "Sad"
        42 -> Ok "Good"
        _ -> Err "Bad"

# Затем можно использовать так:
: Result -> IO String
let foo = res ->
    match res of
        Ok val -> io.puts $ "Result: " <> val
        Err err -> io.puts $ "Error: " <> err
        _ -> io.puts "Unexpected error"

# pattern matching пар:
let pair = ("Dog", "Cat")
#   ^-- () -> Pair(String, String)

io.puts $ 
    match pair of
    "Cat", "Cat"  -> "Both are cats"
    _, "Dog" -> "Second is dog"
    _, _ -> "Neither cat nor dog"

# pattern matching строк:
let string = "Hello, Hroma"
: String -> String
let get_name = x ->
    match x of # String не имеет Copy trait
        "Hello, " <> lang -> lang # это создаст функцию lang -> String, которая будет возвращать остаток после "Hello, "
        _ -> "Unknown"

io.puts (get_name string)

# list pattern matching:
let list = [1, 2, 3]

: List Int -> String
let match_list = l ->
    match l of
        [1] -> "Список состоит только из 1"
        [1, .., 3] -> "Список начинается с 1, заканчивается 3"
        [_, _] -> "Список состоит только из 2 элементов"
        _ -> "Любые другие варианты"

io.puts $ match_list list # >> "Список начинается с 1, заканчивается 3"

---


---

# Tuple (Pair)
# В Hroma вы часто будете сталкиваться с тем, что функция возращает 2 функции -> результат и функцию обратно
: (Int, Int) -> (Int, Int)
let f = a, b -> (b, a + 1) # Тип (Int, Int)

# Пример многострочной функции
let fn = {
    let a = 5
    let b = 37
    (a, b)
}

---

---

# Pipe-операторы

# Императивный стиль:
let list = lists.concat ([1, 2, 3, 4, 5], [1, 2])
list len, _ = lists.len list
io.puts len

# Можно заменить на:

([1, 2, 3, 4, 5], [1, 2])
    ||> lists.concat # эквивалентно lists.concat ([1, 2, 3, 4, 5], [1, 2]) эта функция вернет только новый список
    |> lists.len # эквивалентно lists.len [1, 2, 3, 4, 5, 1, 2] эта функция вернет длину списка и поглощенный список обратно
    |> io.puts # >> 7
    # Хотя предыдущая операция возвращает (Int, List Int), вторая позиция в паре отбрасывается 
    # (так же, как и при let len, _ = lists.len list),
    # если нужно ее сохранить, то используйте ||>
---

---
# Трейты (Traits):
# В Hroma есть система трейтов для ADT типов.
# Один из стандартных трейтов это NonLin

# Для того, чтобы использовать NonLin, каждый вариант ADT должен содержать только нелинейные типы:
let type NonLinADT = {
    Foo
    Bar String
    Baz {foo: Int, bar: String} # Все варианты имеют нелинейные типы
} deriving (NonLin) # Для такого типа будет автоматический нетривиальный drop

main : IO String
let main = {
    let my_baz = Baz {foo: 42, bar: "42"}
    
    let bar = my_baz.foo + my_baz.foo

    io.puts bar # >> 84
    # my_baz дропнется целиком при выходе из скоупа
}

# По умполчанию, все ADT линейны, поэтому для создания линейного ресурса необходимо просто создать нужный тип
let type Resource = {
    Resource {id: String} 
}

# Если тип не реализует NonLin trait, то ему необходимо вручную реализовать Drop trait
impl Drop for LinResource = {
    drop = { id } ->
        unsafe_drop_resource id
        # id очистится автоматически при выходе из скоупа
}

: Resource -> Int
let use_resource = res ->
    match res of
        { foo } -> foo + 42

main : () -> IO String
let main = {
    let my_resource = Resource {id: 42}


    use_resource my_resource # ресурс поглащен
    # На этом моменте автоматически вызовется кастомный drop
}

# Кастомные traits:
let trait Show = {
    show : Self -> String # Self особый тип
}

let type Foo = {
    Foo (String, String)
} 

impl Show for Foo = {
    show = a, b -> a <> " and " <> b
}

: () -> IO String
let main = {
    let my_foo = Foo ("baz", "bar")

    let show_result = show my_foo 

    io.puts show_result # >> "baz and bar"
}

# Traits для полиморфных параметров (generics) (на будущее):
let type Result (T, E) = {
    Ok T
    Err E    
}
# Если оба параметра нелинейны, то результат является нелинейным
auto NonLin for Result T E where T: NonLin, E: NonLin
# Если все параметры реализуют один и тот же трейт, то можно писать так:
