# Определяем название модуля
let module main

# Импортируем стандартный модуль
let import hroma/io 
# Если импортов несколько:
# let import (
#   hroma/io
#   hroma/lists
#   hroma/files
# )

# Определяем основную функцию
let main = {
    # Стоит отметить, что литералы чисел, строк и других стандартных типов в чистом виде в Hroma не являются константами,
    # это анонимные нульярные функции, которые нельзя вызвать. Это никак не влияет на производительность,
    # однако это подкрепляет философию языка - все это функции (ну кроме констант)

    io.println(bar) # Если функция нульярна (не имеет аргументов), то ее вызов не нуждается в круглых скобках
    # io.println(bar()) === io.println(bar)
    
    let baz = 42

    # Ошибка компиляции! Так как в таком случае функция baz() вызывается дважды
    # Так же стоит отметить, что Hroma позволяет shadowing речь об этом пойдет далее
    let bar = baz + baz
}

---
# В Hroma все значения - это функции
# Для создания функции используется ключевое слово let:
let foo = 42 # Создает функции foo(), которая возвращает 42

# Для создания функции, принимающей 1 и более аргументов:
let bar = a: Int, b: Int -> a + b 
# Если аргументы имеют одинаковый тип, то повторное указание типа можно опустить:
let baz = a, b: String -> a <> b # Оператор конкатинации строк, речь об операторах пойдет дальше
# Аргументы у всех функций являются линейными функциями! 
let fn_with_error = a, b: Int -> { # Если тип у аргументов повторяется, каждый раз его можно не указывать (a -> Int, b -> Int)
    let foo = a + 42
    foo + a # Ошибка! a() была использована дважды. Ошибка! b() Не была использована
}

# Синтаксис многострочных функций
let multiline_fn = {
    let foo = 24
    let bar = foo * 2

    bar # В Hroma нет ключего слова return, как во многих ЯП
}

# По умолчанию в Hroma все функции линейны, а значит их можно использовать один и только один раз:
let some_fn = {
    let foo = 42
    let bar = 42
    foo # Ошибка! функция bar не была использована
}

let some_fn2 = {
    let foo = 42
    let bar = foo
    let baz = foo + bar # Ошибка! Функция foo была использоваана дважды

    baz 
}

# Если вы хотите создать нелинейную функцию, то вам нужен синтаксис let! :
let! nonlinear_fn = 42

let linear_fn = nonlinear_fn + nonlinear_fn # Ошибки нет

# Хотя функции называются нелинейными, единственное их отличие, это возможность переиспользования.
# Их аргументы по прежнему линейные функции, возращаемые фунции тоже линейны:
let! nonlin_fn = 42
let res = nonlin_fn # res нелинейная функция!
let foo = res + res # Ошибка!

let! nonlin_fn = a, b: Int -> a # Ошибка! Функция b() не использована

# Нелинейные функции это основной инструмент для создания пользовательских API:
let! query_db = db: Database, query: String -> {
    let! new_db = db # Берем функцию db() во "владение" нашей функции

    let result, _ = driver.query_db(new_db, query)

    match result of
        Ok(row) -> (row, new_db)
        Err(e) -> ("Error query database: " <> e, new_db)
}

let db = driver.connect("localhost")

let res, db2 = query_db(db, "SELECT * FROM foo")
# let res, db3 = query_db(db, "SELECT * FROM baz") # Ошибка! db() использована 2 раза
let res2, db3 = query_db(db2, "SELECT * FROM bar")

let _ = driver.close(db3)

# Если вы создадите нелинейную функцию и используете менее 2 раз, то компилятор выдаст предупреждение
let foo = {
    let! bar = 42
    let baz = bar
    baz # Предупреждение! bar() использована 1 раз. Возможно стоит определить эту функцию, как линейную
}

# (На будущее)
# Нелинейные функции объявленные на верхнем уровне модуля автоматически будут доступны извне

---

---

# Анонимные функции:

let -> {...} # Анонимная нульярная функция

let (a, b) -> {...} # Анонимная ненульярная функция

# стоит отметить, что анонимные функции Вы будете использовать в качестве коллбэков (callback),
# поэтому типы аргументов указывать в таких функциях не нужно. По сути, анонимные функции являются замыканиями
# 
# В остальных случаях указывать тип аргументов является необходимостью
let applicate = x: Int, callback: (Int -> Int) -> callback(x)
let foo = applicate(42, let (a) -> a) # >> 42. В данном случае функция a() автоматически будет иметь тип Int
---

---

# Типы данных:
# В Hroma есть ряд встроенных типов: Int, Float, String, Bool, List(T), Result(T, E), Tuple(..T), Record(..K: T), Pair
# Так как в Hroma - все это функции (кроме констант), эти типы обозначают сигнатуру функции.

# Однако, если в аргумент вы хотите передать ненульярную функцию, то вы можете использовать синтаксис a -> b, где 'a' и 'b' это
# другие типы
#
# Если функция, которую вы передаете в аргумент ненульярна, то ее сигнатуру можно указать подобным образом:
let! factorial = n: Int, cont: (Int -> Int) -> # Пример линейной рекурсии
    match n of
        0 -> cont(1)
        _ -> factorial(n - 1, let (result) -> cont(n * result))
# Удобнее будет вынести в отдельный тип:
let type Cont = Int -> Int
let! falctorial = n: Int, cont: Cont -> {...}

# Так же Hroma поддерживает кастомные типы:
let type MyResult = Result(Bool, String) # Типы обязательно пишутся с большой буквы!
let f -> MyResult = val: Int  -> {match val of ...}

# Кастомными типами так же могут быть примитивные типы:
let type MyString = String

# Так же можно задать несоклько вариантов одному типу
let type MyType = (
    Foo,
    Baz,
    Bar
)
# Затем это удобно использовать в pattern match
let f = variant: MyType ->
    match of variant
        Foo -> "foo!"    
        Bar -> "bar!"
        Baz -> "baz!"
        _ -> "sad"
let _ = io.println(f(Foo)) # >> foo!

# Так же есть возможность объявить свой Record
let type MyRecordType = (
    Foo(data: String, another_data: String)
    Bar(data, another_data: String, life: Int)
)

let handle_record = record: MyRecordType -> 
    match record of
        Foo(data, another_data) -> io.println("Your data: " <> data <> " " <> another_data)
        Bar(_, _, life) -> io.println("Life: " <> life) # Варианты можно пропускать


handle_my_record(Bar("foo", "bar", 42)) # >> 42

# Аргументам функций необходимо явно указывать типы:
let f = a: String -> io.println(a) # Важно отметить, что io.println() возвращает функцию обратно, поэтому мы можем использовать let
# let g = f("foo") # Функция g теперь возвращает foo

# Если типы аргументов одинаковы, томожно не писать тип отдельно каждому аргументу:
let f1 = a, b: Int -> io.println(a + b)
---

---
# Математические операторы:
# Итог любой операции, с использованием математических операторов - это всегда функция. Можно мысленно предстваить,
# что весь блок операций, это одна анонимная нульярная функция, возвращающая в итоге результат. А как мы знаем, в Hroma все функции 
# возвращают только функции.

# Операторы в Hroma не имеют перегрузок:
# Операторы для Int: 
# Арифметические: [+, -, /, *, %]
# Операторы сравнения: [<, >, >=, <=]
#
# Операторы для Float: 
# Арифметические: [+. , -. , /. , *. , %.]
# Операторы сравнения: [<. , >. , >=. , <=.]
#
# Операторы для String
# Оператор конкатинации: <>

# Оператор сравнения работает с любыми типами:
io.println(42 == 42) # >>true
io.println("42" == "42") # >>true
io.println(42 == "42") # Ошибка!
# Выдает ошибку при несоответствии!
---

---

# Коллекции (списки):
let list = [0, 1, 2] # Это функция, которая создаст список.
# Такой список будет иметь тип List(Int)

# Hroma имеет встроенные функции для работы со списками в модуле hroma/lists:
let list = [42, 42, 42]

let len, list = lists.len(list1) # Так как в Hroma функции линейны, после использования в функции len
# функция list() будет недоступна. Поэтому len (как и многие другие функции) возвращает заново новую функцию с исходным списком
# Если вам не нужна функция со списком обратно вы можете сделать let len, _ = len(list)
# Стоит отметить, в Hroma все переменные неизменяемы. В данном примере мы не изменяем переменную, а переопределяем, о этой
# особенности пойдет речь далее
#

---

---
# Pattern matching

# Пример pattern matching:
let matcher = a: Int -> # Result(String, String)
    match a of
        0 -> Ok("Sad")
        42 -> Ok("Good")
        _ -> Err("Bad")

# Затем можно использовать так:
let foo = res: Result(String, String) -> { # Скобки не обязательны !
    match res of
        Ok(val) -> io.println("Result: " <> val)
        Err(err) -> io.println("Error: " <> err)
        _ -> io.println("Unexpected error")
}

# pattern matching кортежей (Tuple):
let tuple = ("Dog", "Cat")

let result = match tuple of
    "Cat", "Cat"  -> "Both are cats"
    _, "Dog" -> "Second is dog"
    _, _ -> "Neither cat nor dog"

# pattern matching строк:
let string = "Hello, Hroma"
let get_name = x: String ->
    let! new_x = x
    match new_x of
        "Hello, " <> lang -> (lang, new_x) # это создаст функцию lang() -> String, которая будет возвращать остаток после "Hello, "
        _ -> ("Unknown", new_x) # Возвращать обратно аргумент является хорошей практикой

let name, _ = get_name(string)
io.println(name) # >> Hroma

# list pattern matching:
let list = [1, 2, 3]

let match_list = l: List(int) ->
    match l of
        [1] -> "Список состоит только из 1"
        [1, .., 3] -> "Список начинается с 1, заканчивается 3"
        [_, _] -> "Список состоит только из 2 элементов"
        _ -> "Любые другие варианты"

io.println(match_list(list)) # >> "Список начинается с 1, заканчивается 3"

---


---

# shadowing

# Так как в Hroma часто приходится переопределять функции, в языке присутсвует shadowing:
let a = 42
foo(a)
let a = 0 # Ошибки не будет. Мы не изменили переменную, а создали новую с тем же именем. Старая при этом удаляется

# Однако важно уточнить, что перед тем, как переопределить функцию, она обязана быть использована до этого
let sorted_list, list = lists.sort(list) # Ошибки нет, так как прямо перед определением функция list была использована

# let list = [42]
# let list = [0] -- Ошибка! Функция переопределена до ее использования
#

# Аргументы функций нельзя переопределить: let foo = a -> {
#    let a = 42 -- Ошибка!
#}

# let len, _ = lists.len(list)
# let filtered, _ = lists.filter(list, let (x) -> {...}) # Ошибка!! Функция list использована дважды
---


---

# Tuple

let tuple = ("42", 42, 42.0, [42]) # Tuple(Stirng, Int, Float, List(Int))

# В Hroma вы часто будете сталкиваться с тем, что функция возращает 2 функции -> результат и функцию обратно
let f = a, b: Int -> (b, a + 1) # Тип Tuple(Int, Int)

# Пример многострочной функции
let fn = {
    let a = 5
    let b = 37
    (a, b)
}

---

---

# Pipe-операторы
let list = [1, 2, 3]


let len, _ = list # Pipe оператор возращает результат последней функции.
    |> lists.filter(let (a) -> a % 2 != 0) # передает в первый аргумент
    |> lists.len
let _ = io.println(len) # >> 2
# Важно! Если функция возращает несколько результатов (Tuple), то выберается первый элемент кортежа
# Record же передается целиком, что стоит учитывать

# Без pipe оператора данная операция выглядела бы так
# let sorted_list, list1 = lists.sort(list, let (a) -> a % 2 != 0)
# let len, _ = lists.len(list1)


# В Hroma правильно будет всегда учитывать, что функция будет использована в pipe операторе, поэтому желательно всегда
# выностить функцию, над которой будут проводится операции в первый аргумент, однако pipe оператор в Hroma позволяет подставлять
# результат предыдущей операции в необходимый по счету аргумент, хотя, опять же, так делать не желательно
let foo, list = list
    |> bar(42, _)

---
